{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#updater","title":"Updater","text":""},{"location":"#what-is-updater","title":"What is Updater?","text":"<p>Updater is a kotlin (java) library for update management.  It has integration with platforms like GitHub, Modrinth, Spigot and more to allow easy setup without much work.  It allows users to specify a custom version schema that allows you to customize your versions as you like.</p> Kotlin GradleMaven build.gradle.kts<pre><code>dependencies {\n  implementation(\"io.github.vxrpenter:updater:VERSION\")\n}\n</code></pre> pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.vxrpenter&lt;/groupId&gt;\n    &lt;artifactId&gt;updater&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>VERSION</code> with the latest version</p>"},{"location":"setup/installation/","title":"Installation","text":"<p>Installation is easy and straightforward, just add the library to your build config.</p> <p></p> Kotlin GradleMaven build.gradle.kts<pre><code>dependencies {\n  implementation(\"io.github.vxrpenter:updater:VERSION\")\n}\n</code></pre> pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.vxrpenter&lt;/groupId&gt;\n    &lt;artifactId&gt;updater&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>VERSION</code> with the latest version</p>"},{"location":"setup/logging/","title":"Logging","text":"<p>Danger</p> <p>A missing logging framework will hinder the application from starting</p> <p>You can use all logging frameworks compatible with the SLF4J logging facade, but the usage of logback is encouraged.</p> Kotlin GradleMaven build.gradle.kts<pre><code>dependencies {\n  implementation(\"ch.qos.logback:logback-classic:VERSION)\n}\n</code></pre> pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>VERSION</code> with the latest version</p>"},{"location":"setup/logging/#configuration","title":"Configuration","text":"<p>This configuration has been taken from the jda wiki because it has a consistent styling and is understandable.</p> logback.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-34.-34thread) %red(%10.10X{jda.shard}) %boldGreen(%-15.-15logger{0}) %highlight(%-6level) %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\" /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"using-updater/","title":"Getting Started","text":"<p>Just a simple example</p> <p>This is a small quickstart guide that can also be found in the GitHub README,  read throught the rest of the docs for a more thorough overview</p>"},{"location":"using-updater/#creating-a-schema","title":"Creating a Schema","text":"<p>To begin, we have to create an UpdateSchema that allows the library to decode your versions into readable components and classifiers. The example below shows how such a schema could look. It uses the <code>Schema</code> function which uses the <code>SchemaBuilder</code> to create a <code>DefaultSchema</code>. Most upstreams will accept a <code>DefaultSchema</code> but some will beed specific schema types, so keep an eye out for that.</p> <p>The classifiers that can be added using the <code>SchemaBuilder</code> are <code>DefaultClassifiers</code> but some upstreams wil require custom classifiers so also keep an eye out for that.</p> <p>Example</p> <pre><code>val schema = Schema {\n    // The prefix stands before the actual version, e.g. 'v1.0.0'\n    prefixes = listOf(\"v\")\n    // The symbol that divides the version numbers\n    divider = \".\"\n    // A classifier is an argument that can be added to a version that defines if it's a 'special' version\n    // like an alpha or beta release\n    classifier {\n        // The classifier identifier value\n        value = \"a\"\n        // The divider between identifier value and version number\n        divider = \"-\"\n        // Divider between the components\n        componentDivider = \".\"\n        // The priority that the classifier has in comparison to other classifiers\n        priority = 1.priority\n    }\n    // Some extra classifiers for showcase\n    classifier {\n        value = \"b\"\n        divider = \"-\"\n        componentDivider = \".\"\n        priority = 2.priority\n    }\n    classifier {\n        value = \"rc\"\n        divider = \"-\"\n        componentDivider = \".\"\n        priority = 3.priority\n    }\n}\n</code></pre>"},{"location":"using-updater/#configuring-the-upstream","title":"Configuring the Upstream","text":"<p>The next step will be configuring the upstream (the location that we upload our versions). In this example, we will use GitHub as our upstream. You will need to enter certain information needed to fetch your project from the upstream api.</p> <p>Example</p> <pre><code>val upstream = GitHubUpstream(user = \"Vxrpenter\", repo = \"Updater\")\n</code></pre>"},{"location":"using-updater/#checking-for-updates","title":"Checking for Updates","text":"<p>The last thing will be to check for new versions. This can be easily achieved by invoking the <code>Updater</code> class and then calling the <code>checkUpdates</code> function. It will require you to enter the current version of your project (if you want to know how to get the current version, look here followed by the <code>UpdateSchema</code> and the <code>Upstream</code>.</p> <p>You are also able to configure certain behaviors of the <code>Updater</code> like adding a periodic check, customizing the notification message, configuring the read/write timeout, etc.</p> <p>Example</p> <pre><code>Updater.checkUpdates(currentVersion = \"v1.0.0\", schema = schema, upstream = upstream) {\n    periodic = 10.minutes\n    notification {\n        notify = true\n        notification = \"A new version has arrived. Version {version} can be downloaded the link {url}\"\n    }\n}\n</code></pre>"},{"location":"using-updater/checking-for-versions/","title":"Checking for Versions","text":"<p>Note</p> <p>You need to have already created an UpdateSchema and configured your Upstream to continue here.</p>"},{"location":"using-updater/checking-for-versions/#checking-using-a-single-upstream","title":"Checking using a single Upstream","text":"<p>To check for an update using a single upstream, you first need to invoke the <code>Updater</code> class. After that, call the <code>checkUpdates</code> function.</p> <p>It checks for new updates by fetching the version from the specified upstream, then it compares the current version to the fetched one and (when enabled) returns a notification.</p> <p>Example</p> <pre><code>Updater.checkUpdates(currentVersion = \"VERSION\", schema = schema, upstream = GitHubUpstream(\"Vxrpenter\", \"Updater\"))\n</code></pre> <p>If you need to configure the updater, refer to this</p>"},{"location":"using-updater/checking-for-versions/#checking-using-multiple-upstreams","title":"Checking using multiple Upstreams","text":"<p>When you have multiple upstreams you upload your versions to, you might want to check them all to find a new update. To do this, you can simply call the <code>checkMultipleUpdates</code> function.</p> <p>It checks for new updates by fetching versions from multiple upstreams.  It then compares the versions by first checking for the biggest returned version.</p> <p>If the returned versions from at least 2 upstreams are equal, the prioritized upstream will be selected by comparing them using their Priority.</p> <p>Example</p> <pre><code>Updater.checkMultipleUpdates(currentVersion = \"VERSION\", schema = schema, upstreams = listOf(\n    GitHubUpstream(\"Vxrpenter\", \"PROJECT\", upstreamPriority = 1.priority),\n    ModrinthUpstream(\"PROJECT\", ModrinthProjectType.MOD, upstreamPriority = 2.priority)\n))\n</code></pre>"},{"location":"using-updater/checking-for-versions/#configure-updater","title":"Configure Updater","text":"<p>Note</p> <p>This is not a guide to the configurations functions, refer to the Configuration section for more information.</p> <p>There are 2 possible ways to configure the updater, with the first as the recommended.</p>"},{"location":"using-updater/checking-for-versions/#configuration-direct","title":"Configuration Direct","text":"<p>After calling any function from the updater class, you can easily add configuration option to it using the builder.</p> <p>Example</p> <pre><code>Updater.checkUpdates(currentVersion = \"VERSION\", schema = schema, upstream = GitHubUpstream(\"Vxrpenter\", \"Updater\")) {\n    periodic = 10.seconds\n    notification {\n        notify = true\n        message = \"A new version has arrived. Version {version} can be downloaded with the link {url}\"\n    }\n}\n</code></pre>"},{"location":"using-updater/checking-for-versions/#configuration-in-constructor","title":"Configuration in Constructor","text":"<p>You can also create a configuration with the <code>ConfigurationBuilder</code> by calling the <code>configuration</code> function, outside any updater function.</p> <p>Example</p> <pre><code>val configuration = Configuration {\n    periodic = 10.seconds\n    notification {\n        notify = true\n        message = \"A new version has arrived. Version {version} can be downloaded with the link {url}\"\n    }\n}\n</code></pre> <p>Then simply set the <code>configuration</code> parameter in the <code>Updater</code> constructor to your config.</p> <p>Example</p> <pre><code>Updater(configuration).checkUpdates(currentVersion = \"v1.0.0\", schema = schema, upstream = GitHubUpstream(\"Vxrpenter\", \"Updater\"))\n</code></pre>"},{"location":"using-updater/configuration/","title":"Configuration","text":"<p>The <code>Configuration</code> defines the behavior of the <code>Updater</code> class, <code>HttpClient</code> and more.</p>"},{"location":"using-updater/configuration/#create-configuration","title":"Create Configuration","text":"<p>To create a configuration outside a function in the <code>Updater</code> class, invoke the <code>Configuration</code> function which will allow you to easily create a configuration using the <code>ConfigurationBuilder</code>.</p> <p>Example</p> <pre><code>val configuration = Configuration {\n    // Time between\n    periodic = 10.seconds\n    // Timeout configuration when reading data\n    readTimeout = 120.seconds\n    // Timeout configuration when writing data\n    writeTimeout = 120.seconds\n    notification {\n        // Notify the user about a new version\n        notify = true\n        // Notification Message\n        message = \"A new version has arrived. Version {version} can be downloaded with the link {url}\"\n    }\n}\n</code></pre> <p>To then use this configuration with the <code>Updater</code> class, invoke <code>Updater</code> and add the configuration in the constructor.</p> <p>Example</p> <pre><code>val updater = Updater(configuration = configuration)\n</code></pre>"},{"location":"using-updater/current-version/","title":"Current Version","text":"<p>The easiest way to get the current version of your project from the <code>build.gradle.kts</code> is by adding a task to create a properties file. This file will be created when the project is compiled and can be read at runtime. First, we will need to set up the task to create the properties file: build.gradle.kts<pre><code>val createVersionProperties by tasks.registering(WriteProperties::class) {\n    val filePath = sourceSets.main.map {\n        it.output.resourcesDir!!.resolve(\"${layout.buildDirectory}/resources/version.properties\")\n    }\n    destinationFile = filePath\n\n    property(\"version\", project.version.toString())\n}\n\ntasks.classes {\n    dependsOn(createVersionProperties)\n}\n</code></pre></p> <p>To get the version from the properties file at runtime, you will need to first load the properties file and then retrieve the property <code>version</code> from it: <pre><code>class TestClass {\n    fun main() {\n        val properties = Properties()\n\n        TestClass::class.java.getResourceAsStream(\"DIRECTORY/resources/version.properties\").use {\n                versionPropertiesStream -&gt; checkNotNull(versionPropertiesStream) { \"Version properties file does not exist\" }\n            properties.load(InputStreamReader(versionPropertiesStream, StandardCharsets.UTF_8))\n        }\n\n        val version = properties.getProperty(\"version\")\n    }\n}\n</code></pre></p>"},{"location":"using-updater/update-schemas/","title":"Update Schemas","text":"<p>Update Schemas are a way to define instructions on how to read and compare versions.</p>"},{"location":"using-updater/update-schemas/#defaultupdateschema","title":"DefaultUpdateSchema","text":"<p>The <code>DefaultUpdateSchema</code> is as the name implies the default schema that will be used by most Upstreams. It contains configurations which are unspecific to any upstream and are most often paired with the <code>DefaultSchemaClassifier</code>.</p> <p>Using the builtin <code>SchemaBuilder</code>, you can easily create a <code>DefaultUpdateSchema</code>. Just call the <code>Schema</code> function and begin configuring.</p> <p>Example</p> MyFile.kt<pre><code>val schema = Schema {\n    // The prefix stands before the actual version, e.g. 'v1.0.0'\n    prefixes = listOf(\"v\")\n    // The symbol that divides the version numbers\n    divider = \".\"\n    // A classifier is an argument that can be added to a version that defines if it's a 'special' version\n    // like an alpha or beta release\n    classifier {\n        // The classifier identifier value\n        value = \"a\"\n        // The divider between identifier value and version number\n        divider = \"-\"\n        // Divider between the components\n        componentDivider = \".\"\n        // The priority that the classifier has in comparison to other classifiers\n        priority = 1.priority\n    }\n}\n</code></pre>"},{"location":"using-updater/update-schemas/#custom-classifiers","title":"Custom Classifiers","text":"<p>Danger</p> <p>When not provided with the correct type of <code>SchemaClassifier</code>, the Upstream will throw a <code>ClassifierTypeMismatch</code></p> <p>Some Upstreams will require you to use a custom <code>SchemaClassifier</code>.  If such a usage is required, it will most often be stated in the upstreams <code>fetch</code> function documentation.</p> <p>When using the <code>SchemaBuilder</code>, you can easily add a custom classifier with the <code>customClassifier</code> function.</p> <p>Example</p> MyFile.kt<pre><code>val schema = Schema {\n    prefix = listOf(\"v\")\n    divider = \".\"\n    customClassifier(HangarSchemaClassifier(\n        value = \"rc\",\n        divider = \"-\",\n        componentDivider = \".\",\n        priority = 2.priority,\n        channel = \"Beta\"\n    ))\n}\n</code></pre>"},{"location":"using-updater/update-schemas/#schemas-indepth","title":"Schemas Indepth","text":"<p>This section goes into the indepth function/purpose of the values inside the <code>DefaultUpdateSchema</code> as it is equal to the default <code>UpdateSchema</code> interface values.</p>"},{"location":"using-updater/update-schemas/#prefixes","title":"Prefixes","text":"<p>The prefixes are a collection of symbols that stand before the rest of the version string. This can be a simple <code>v</code> or <code>v.</code>, or even something like <code>version(new)-</code>.  This collection will not be used for any comparisons and is generally removed. The removal is generally done by replacing the prefixes with an empty string.</p>"},{"location":"using-updater/update-schemas/#divider","title":"Divider","text":"<p>The divider defines the symbol that is inbetween the version components. A version component in this context is a number inside a version string, e.g. <code>1</code> out of <code>1.0.0</code>. This divider will be used to split the version.</p> <p>Each <code>Version</code> will implement this on its own so the behavior can differentiate.</p>"},{"location":"using-updater/update-schemas/#classifiers-indepth","title":"Classifiers Indepth","text":"<p>This section goes into the indepth function/purpose of the values inside the <code>DefaultSchemaClassifier</code> as it is equal to the default <code>SchemaClassifier</code> interface values.</p>"},{"location":"using-updater/update-schemas/#value","title":"Value","text":"<p>The value defines the name of the classifier, e.g. <code>rc</code>, <code>alpha</code>, <code>beta</code>, etc. This name will be used (after pairing it with the Divider) to remove the classifiers naming, to retrieve the classifier version components.</p>"},{"location":"using-updater/update-schemas/#divider_1","title":"Divider","text":"<p>The divider defines the symbol that divides the classifier from the classifier version string, e.g. <code>-</code> or <code>+</code>. This can even be the Divider of the schema, as the divider will be paired with the Value before removal.</p>"},{"location":"using-updater/update-schemas/#componentdivider","title":"ComponentDivider","text":"<p>The ComponentDivider defines the symbol that is inbetween the version components. A version component in this context is a number inside a version string, e.g. <code>1</code> out of <code>1.0.0</code>. This divider will be used to split the version.</p> <p>Each <code>Classifier</code> will implement this on its own so the behavior can differentiate.</p>"},{"location":"using-updater/update-schemas/#priority","title":"Priority","text":"<p>The priority defines the importance of  a <code>SchemaClassifer</code>. This is used to compare different <code>SchemaClassifiers</code> to find the prioritized one.</p>"},{"location":"using-updater/update-schemas/#custom-update-schemas","title":"Custom Update Schemas","text":"<p>Warning</p> <p>Using custom schemas also requires you to create custom Upstreams,  custom SchemaClassifiers as well as custom Versions.</p> <p>When handling versions with special parameters, the <code>DefaultUpdateSchema</code> may not suffice. If you have such a special version, creating a custom <code>UpdateSchema</code> may proof useful.</p> <p>To create a custom <code>UpdateSchema</code> you will first need to create a class (preferably a data class) that extends <code>UpdateSchema</code> and override the <code>prefix</code>, <code>divider</code> and <code>classifier</code> values.</p> <p>Example</p> CustomUpdateSchema.kt<pre><code>data class CustomUpdateSchema(\n    override val prefixs: Collection&lt;String&gt;,\n    override val divider: String,\n    override val classifiers: Collection&lt;SchemaClassifier&gt;\n) : UpdateSchema {\n\n}\n</code></pre> <p>Then you are able to add specific values, as well as functions to the class, to handle the special attributes that your version introduces.</p> <p>Example</p> CustomUpdateSchema.kt<pre><code>data class CustomUpdateSchema(\n    override val prefix: Collection&lt;String&gt;,\n    override val divider: String,\n    override val classifiers: Collection&lt;SchemaClassifier&gt;,\n    val description: String,\n    val user: String\n) : UpdateSchema {\n\n    fun doSomethingWithUser() {\n        TODO(\"Not yet implemented\")\n    }\n\n}\n</code></pre>"},{"location":"using-updater/update-schemas/#custom-schema-classifiers","title":"Custom Schema Classifiers","text":"<p>Custom Schema Notice</p> <p>Using custom schema classifiers also requires you to create custom Upstreams,  custom UpdateSchemas as well as custom Versions.</p> <p>When handling versions with special classifiers, the <code>DefaultSchemaClassifier</code> may not suffice. If you have such a special classifiers, creating a custom <code>SchemaClassifier</code> may proof useful.</p> <p>To create a custom <code>SchemaClassifier</code> you will first need to create a class (preferably a data class) that extends <code>SchemaClassifier</code> and override the <code>value</code>, <code>priority</code>, <code>divider</code> and <code>componentDivider</code> values.</p> <p>Example</p> CustomUpdateSchema.kt<pre><code>data class CustomUpdateSchema(\n    override val value: String,\n    override val priority: Priority,\n    override val divider: String,\n    override val componentDivider: String\n) : SchemaClassifier {\n\n}\n</code></pre> <p>Then you are able to add specific values, as well as functions to the class, to handle the special classifier that your version introduces.</p> <p>Example</p> CustomUpdateSchema.kt<pre><code>data class CustomUpdateSchema(\n    override val value: String,\n    override val priority: Priority,\n    override val divider: String,\n    override val componentDivider: String,\n    val description: String,\n    val user: String\n) : SchemaClassifier {\n\n    fun doSomethingWithUser() {\n        TODO(\"Not yet implemented\")\n    }\n\n}\n</code></pre>"},{"location":"using-updater/upstreams/","title":"Upstreams","text":"<p>An <code>Upstream</code> defines a remote location where version data is hosted. The <code>Upstream</code> also implements ways to fetch this data, convert it and generate <code>Updates</code> from it.</p>"},{"location":"using-updater/upstreams/#default-upstreams","title":"Default Upstreams","text":"<p>By default, a selection of  already configured upstreams is provided.  They can be used to query version data and generally (but not limited to) consist of the <code>GitHubUpstream</code> and the <code>ModrinthUpstream</code>.</p> <p>You can configure an upstream by invoking it and providing it with the needed information.</p> <p>Example</p> MyFile.kt<pre><code>val upstream = GitHubUpstream(user = \"Vxrpenter\", repo = \"Updater\")\n</code></pre>"},{"location":"using-updater/upstreams/#custom-upstreams","title":"Custom Upstreams","text":"<p>When you are hosting your versions on an upstream that is not defined by default, you will have to create a custom upstream to fetch the version information.</p> <p>To create a custom <code>Upstream</code> you will first need to create a class (preferably a data class) that extends <code>Upstream</code> and override the <code>upstreamPriority</code> and the functions, as well as adding the values that are needed to find the location of your project on the upstreams api.</p> <p>Example</p> CustomUpstream.kt<pre><code>data class CustomUpstream(\n    override val upstreamPriority: UpstreamPriority\n) : Upstream {\n    override suspend fun fetch(client: HttpClient, schema: UpdateSchema): Version? {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun toVersion(version: String, schema: UpdateSchema): Version {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun update(version: Version): Update {\n        TODO(\"Not yet implemented\")\n    }\n\n}\n</code></pre>"},{"location":"using-updater/upstreams/#fetch-function","title":"Fetch Function","text":"<p>Tip</p> <p>It is recommended to foolproof the request logic by checking for request failures  and catching possible <code>SerializationException</code> if the response body has to be serialized.</p> <p>The fetch function generally consists of two parts, the requesting and the returning of the version.</p> <p>Example</p> CustomUpstream.kt<pre><code>override suspend fun fetch(client: HttpClient, schema: UpdateSchema): Version? {\n    // Fetching logic goes here\n\n    // Body is here a decoded response body\n    val value = body.first().tagName\n    // Creates the components and classifiers for a DefaultVersion and DefaultClassifier from the returned version string\n    val components = DefaultVersion.components(value = value, schema = schema)\n    val classifier = DefaultClassifier.classifier(value = value, schema = schema)\n}\n</code></pre>"},{"location":"using-updater/upstreams/#toversion-function","title":"ToVersion Function","text":"<p>A simple function to convert a version string into a <code>Version</code>.</p> <p>Example</p> CustomUpstream.kt<pre><code>override fun toVersion(version: String, schema: UpdateSchema): Version {\n    return DefaultVersion(version, DefaultVersion.components(version, schema), DefaultClassifier.classifier(version, schema))\n}\n</code></pre>"},{"location":"using-updater/upstreams/#update-function","title":"Update Function","text":"<p>Warning</p> <p>Incorrect handling of the interpretation can cause unexpected problems due to user error.</p> <p>The update function is used to generate an <code>Update</code> from a given <code>Version</code> that can be used elsewhere. To do this, we will need to interpret the <code>Version</code> interface as the actual used implementation of the <code>Version</code>.</p> <p>Example</p> CustomUpstream.kt<pre><code>override fun update(version: Version): Update {\n    // Interprets version as DefaultVersion and throws an exception when it is not\n    if (version !is DefaultVersion) throw VersionTypeMismatch(\"Version type ${version.javaClass} cannot be ${DefaultVersion::class.java}\")\n}\n</code></pre> <p>We then return some form of <code>Update</code> that contains the values we are able to return.</p> <p>Example</p> CustomUpstream.kt<pre><code>// This is just an example, do not hardcode your url like this, when possible\nval releaseUrl = \"https://github.com/Vxrpenter/Updater/releases/tag/${version.value}\"\n\nreturn DefaultUpdate(value = version.value, url = releaseUrl)\n</code></pre>"},{"location":"using-updater/versions/","title":"Versions","text":"<p>Versions are version strings that have been split into their specific components and classifiers for easier usage and readability.</p>"},{"location":"using-updater/versions/#defaultversions-and-defaultclassifiers","title":"DefaultVersions and DefaultClassifiers","text":"<p>The <code>DefaultVersion</code> and <code>DefaultClassifier</code> are the most commonly used versions and classifiers, because they implementation the most important values for their respective types.</p> <p>The <code>DefaultVersion</code> contains a <code>components</code> function as a companion object and the <code>DefaultClassifier</code> a <code>classifier</code> function. They are used to create the specific components or <code>DefaultClassifier</code> from a version string.</p> <p>Example</p> GitHubUpstream.kt<pre><code>val value = \"VERSION\"\n\nval components = DefaultVersion.components(value = value, schema = schema)\nval classifier = DefaultClassifier.classifier(value = value, schema = schema)\n</code></pre>"},{"location":"using-updater/versions/#custom-versions","title":"Custom Versions","text":"<p>When your version contains special parameters, you may want to create a custom one.</p> <p>To create a custom <code>Version</code>, you will first need to create a class (preferably a data class) that extends <code>Version</code> and override the <code>value</code>, <code>components</code>, <code>classifier</code> values and the functions.</p> <p>Example</p> CustomVersion.kt<pre><code>data class CustomVersion(\n    override val value: String\n) : Version {\n    companion object {\n        fun components(value: String, schema: UpdateSchema): Collection&lt;String&gt; {\n            TODO(\"Not yet implemented\")\n        }\n    }\n\n    override fun compareTo(other: Version): Int {\n        TODO(\"Not yet implemented\")\n    }\n\n}\n</code></pre>"},{"location":"using-updater/versions/#compareto-function","title":"CompareTo Function","text":"<p>The compareTo function is used to compare a version to another version.</p> <p>Example</p> CustomVersion.kt<pre><code>override fun compareTo(other: Version): Int { other as DefaultVersion\n    if (components.size != other.components.size) throw VersionSizeMismatch(\"Size of version components are not equal\")\n    components.zip(other.components).forEach { (subVersion, otherSubVersion) -&gt;\n        if (subVersion != otherSubVersion) return subVersion.compareTo(otherSubVersion)\n    }\n\n    if (classifier != other.classifier) return when {\n        classifier == null -&gt; 1\n        other.classifier == null -&gt; -1\n        else -&gt; return classifier.compareTo(other.classifier)\n    }\n\n    return 0\n}\n</code></pre>"},{"location":"using-updater/versions/#components-function","title":"Components Function","text":"<p>Note</p> <p>This function is located inside the companion object to allow invokations without initializing the version</p> <p>The components function returns a collection of strings (components) from a version string.  These components are the individual numbers in the version.</p> <p>Example</p> CustomVersion.kt<pre><code>fun components(value: String, schema: UpdateSchema): Collection&lt;String&gt; {\n    val version = value.replace(schema.prefix, \"\")\n    var preSplit = version\n\n    for (classifier in schema.classifiers) {\n        val classifierElement = \"${classifier.divider}${classifier.value}\"\n        if (!version.contains(classifierElement)) continue\n\n        preSplit = version.split(classifierElement).first()\n    }\n\n    return preSplit.split(schema.divider)\n}\n</code></pre>"},{"location":"using-updater/versions/#custom-classifiers","title":"Custom Classifiers","text":"<p>When your classifier contains special parameters, you may want to create a custom one.</p> <p>To create a custom <code>Classifier</code> you will first need to create a class (preferably a data class) that extends <code>Classifier</code> and override the <code>value</code>, <code>priority</code>, <code>components</code> values and the functions.</p> <p>Example</p> CustomClassifier.kt<pre><code>data class CustomClassifier(\n    override val value: String\n) : Classifier {\n    companion object {\n        fun classifier(value: String, schema: UpdateSchema): DefaultClassifier? {\n            TODO(\"Not yet implemented\")\n        }\n    }\n\n    override fun compareTo(other: Classifier): Int {\n        TODO(\"Not yet implemented\")\n    }\n\n}\n</code></pre>"},{"location":"using-updater/versions/#compareto-function_1","title":"CompareTo Function","text":"<p>The compareTo function is used to compare a classifier to another version.</p> <p>Example</p> CustomClassifier.kt<pre><code>override fun compareTo(other: Classifier): Int { other as DefaultClassifier\n    if (components.size != other.components.size) throw VersionSizeMismatch(\"Size of classifier components are not equal\")\n    if (components.isEmpty()) return priority.value.compareTo(other.priority.value)\n\n    components.zip(other.components).forEach { (subVersion, otherSubVersion) -&gt;\n        if (subVersion != otherSubVersion) return subVersion.compareTo(otherSubVersion)\n    }\n\n    return 0\n}\n</code></pre>"},{"location":"using-updater/versions/#classifier-function","title":"Classifier Function","text":"<p>Note</p> <p>This function is located inside the companion object to allow invokations without initializing the version</p> <p>The classifier function returns a classifier from a version string.  The classifier will be paired with the <code>ClassifierPriority</code> from the <code>UpdateSchema</code>.</p> <p>Example</p> CustomClassifier.kt<pre><code>fun classifier(value: String, schema: UpdateSchema): DefaultClassifier? {\n    val version = value.replace(schema.prefix, \"\")\n\n    for (classifier in schema.classifiers) {\n        val classifierElement = \"${classifier.divider}${classifier.value}\"\n        if (!version.contains(classifierElement)) continue\n\n        val value = \"$classifierElement${version.split(classifierElement).last()}\"\n        val components = version.split(classifierElement).last().split(classifier.componentDivider)\n\n        return DefaultClassifier(value, classifier.priority, components)\n    }\n\n    return null\n}\n</code></pre>"}]}